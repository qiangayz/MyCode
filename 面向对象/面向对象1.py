#coding=utf-8
"""
class 类 #对一类拥有相同属性的对象的抽象、蓝图、原型,在类中定义了这些对象都具备的属性、共同方法
object对象 一个对象就是一个类的实例化模型，一个类必须经过实例化后才能在程序中调用，一个类可以实例化多个对象
类的三大特性：
1、封装
在类中对数据赋值。内部调用对外部用户是透明的、里面包含着类的数据和方法、类似一个胶囊或者容器
2、继承
一个类可以派生出子类，在这个父类中定义的方法属性可以被子类继承
3、多态
例：老板让所有员工开始工作，老板只需要说开始工作，而不需要对各类员工下达任务、类似财务部、行政部、技术部等、
即一个接口，多种实现。
编程的两大原则：
1、写重复代码是非常不好的低级行为
2、写的代码需要经常变更
类的构造函数的初始化过程
首先一般函数的执行流程是：
def funtion(x):
    x += 1
    return x
value = funtion(x)
调用过程是funtion函数运行之后返回一个值这个值会存到一个内存里面，他的变量名（门牌号）是value
当写好一个类模型后，这个类会存到一个内存中，先记为：内存1 内存1中包含的东西，初始化函数，初始化属性，方法
在初始化类的实例的时候
即ri = role(name) 会在内存中开辟第二个内存空间，记为：内存2，里面会存这个实例化的具体值，即r1的name.等属性
即实例化的过程是为r1 = role.__init__(name),返回一个内存，事实上在类的实例化过程中内存2还会把r1存进去，即门牌号所以说实例化时候实际上需要这些参数
r1 = role(r1,name)
那么既然多了一个参数，所有__init__函数里面就需要加一个参数，即role.__init__(r1,name),内存2里面存的属性为ri.name 等
再说类方法，类方法放到哪一个内存里面都不会改变方法里面的东西，所以没必要在内存2里面也存进去方法，所以初始化的时候并没有把类方法也存到实例的内存里面，
那么当实例需要调用这个方法时候，实际上就是r1.funtion1，而funtion没在r1的内存里面啊，所以必须要调用role.funtion，那么调用role的funtion就必须要告诉funtion是哪个对象使用的我了
所以就是这样调用的r1.funtion（）=role.funtion1（r1），所以类的方法里面就必需加一个参数了即funtion（self）这个self有什么用比如
def funtion1(r1):
    print r1.name
如果没有r1,那么你怎么得到r1.name呢？
而这个r1就是我们类里面的self的由来

"""


class Role():
    def __init__(self,name):    #构造函数，在实例化时做一些初始化工作
        self.name = name

    def funtion1(self):
        print self.name

r1 = Role("zq")
print id(r1)
print id(r1.name)
print id(Role)